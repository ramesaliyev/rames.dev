<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>clip | rames.dev</title>
    <meta name="description" content="Clip by Rameş Aliyev.">
    <meta name="keywords" content="rameş, aliyev, rames.dev, ramesaliyev">
    <meta name="author" content="Rameş Aliyev">
    <link rel="icon" type="image/png" href="https://rames.dev/img/common/favicon.png" />

    <!-- OG -->
    <meta property="og:title" content="clip | rames.dev" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://clip.rames.dev" />
    <meta property="og:image" content="https://rames.dev/img/common/avatar.jpeg" />

    <!-- Assets -->
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/main.css">

    <style>
      :root {
        --yellow: #fff8c9;
        --red: #ffb3b3;
        --green: #e2ffd9;
        --blue: #cceeff;
      }

      ul, li {
        border: none;
        margin: 0;
        padding: 0;
        outline: none;
        box-sizing: border-box;
      }

      textarea, input {
        &:focus {
          background-color: var(--yellow);
        }
      }

      .hidden {
        display: none;
      }

      .session-controls {
        display: flex;
        justify-content: space-between;
        gap: 10px;

        li {
          display: flex;
        }

        .slug {
          flex: 1;

          div {
            border: 2px solid #000;
            border-right: none;
            border-radius: 4px 0px 0px 4px;
            padding: 5px;
            user-select: none;
            display: flex;
            align-items: center;
            font-weight: 800;
            background-color: #eaeaea;
            color: #333;
          }

          input {
            border-radius: 0px 4px 4px 0px;
          }
        }
      }

      .separator {
        border-top: 2px dashed #ccc;
        margin: 20px auto;
        width: 99%;
      }

      .status-box {
        text-align: center;
        border: 2px dashed #000;
        padding: 18px;
        font-weight: 700;
        border-radius: 4px;

        &.error {
          border-color: var(--red);
          color: red;
        }
      }

      .danger-button:hover,
      .safe-button:hover {
        color: #000;
      }

      .danger-button {
        &:hover {
          background-color: var(--red);
        }
        &:focus {
          outline: 2px solid var(--red);
        }
      }

      .safe-button {
        &:hover {
          background-color: var(--blue);
        }
        &:focus {
          outline: 2px solid var(--blue);
        }
      }

      .success-button {
        &, &:hover, &:focus {
          background-color: var(--green);
        }
      }

      input:disabled,
      textarea:disabled,
      button:disabled {
        &, &:hover, &:focus {
          background-color: #f0f0f0;
          color: #888;
          cursor: not-allowed;
        }
      }

      .bg-diaglines {
        --angle: -45deg;
        background: repeating-linear-gradient(
          var(--angle),                   /* diagonal angle */
          #eaeaea,                /* first color */
          #eaeaea 1px,            /* thickness of first stripe */
          white 1px,              /* gap starts */
          white 5px               /* thickness of second stripe + gap */
        );

        &.angle-45 { --angle: 45deg; }
      }

      .entries-wrapper {
        margin: 20px 0;
      }

      #entries {
        margin: 20px 0;
      }

      #no-entries {
        user-select: none;
      }

      .entry-item {
        margin: 10px 0;
      }

      .entry-header {
        border: 2px solid #000;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        cursor: pointer;
        padding: 10px;
        border-bottom-width: 4px;
        user-select: none;
      }

      .entry-summary {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 90%;
      }

      .chev {
        width: 14px;
        height: 14px;
        transform: rotate(-90deg);
        transition: transform .2s ease;
      }

      .entry-id {
        font-weight: 800;
        color: #666;
        font-size: 0.75rem;
        align-items: center;
        display: flex;
      }

      .entry-body {
        display: none;
        border: 2px solid #000;
        border-radius: 0 0 4px 4px;
        border-top-width: 0;
        padding: 10px;
        transition: transform .2s ease;
      }

      .entry-content {
        margin-bottom: 15px;
        border-bottom: 2px dashed;
        padding-bottom: 15px;
        font-size: 0.8rem;
        white-space: pre-wrap;
      }

      .entry-footer {
        display: flex;
        justify-content: space-between;
      }

      .entry-item.expanded {
        .entry-header {
          border-radius: 4px 4px 0 0;
          border-bottom-width: 2px;
        }

        .entry-body {
          display: block;
        }

        .chev {
          transform: rotate(0deg);
        }
      }

      .save-form-wrapper {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 20px;

        textarea {
          min-height: auto;
        }

        .save-form {
          display: flex;
          flex-direction: column;

          textarea {
            border-radius: 4px 4px 0px 0px;
            height: 80px;
            border-bottom: none;
          }

          button {
            border-radius: 0 0 4px 4px;
          }
        }

        .save-status {
          text-align: center;
          overflow-wrap: break-word;

          strong {
            background-color: var(--yellow);
            display: inline-block;
            padding: 0 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-weight: 800;
          }
        }
      }

      .footnote {
        font-size: 0.7rem;
        text-align: center;
        color: #333;
        margin: 20px auto;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <nav>
          <a class="active" href="https://rames.dev">go home</a>
          / <a class="active" href="https://utils.rames.dev">all utils</a>
      </nav>
      <main>
        <ul class="session-controls">
          <li class="slug">
            <div>Slug</div>
            <input id="slugInput" type="text" placeholder="is the access key for this vault..." autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" />
          </li>
          <li>
            <button id="purgeButton" class="danger-button" disabled>Purge</button>
          </li>
        </ul>
        <div class="separator"></div>
        <div class="entries-wrapper">
          <div id="entryStatus" class="status-box bg-diaglines angle-45">Loading...</div>
          <ul id="entryList" class="hidden"></ul>
        </div>
        <div class="separator"></div>
        <div class="save-form-wrapper">
          <div class="save-form">
            <textarea id="saveInput" placeholder="Type something..." rows="1"></textarea>
            <button id="saveButton" class="safe-button">Save</button>
          </div>
          <div id="saveStatusLabel" class="save-status status-box bg-diaglines angle-45 hidden"></div>
        </div>
        <div id="footnote" class="footnote hidden">
          All vaults are automatically purged 24 hours after last write. This vault is scheduled for auto-purge at <strong>10.12.2023 23:48</strong>. You can also purge it manually by clicking the "Purge" button above.
        </div>
      </main>
    </div>

    <script type="module">
      /**
       * Utils Class
       * Contains utility functions for the application.
       */
      class Utils {
        static debounce(fn, delay = 250) {
          let t = null;
          let ac = null;
          let lastArgs = null;
          let lastThis = null;

          return function (...args) {
            lastArgs = args; 
            lastThis = this;

            // If there's already a scheduled call, cancel it.
            if (t) clearTimeout(t);

            // If the previous run was async and still running, cancel it.
            if (ac) ac.abort();

            // Create a new AbortController for the *upcoming* run
            ac = new AbortController();

            // Schedule the call after 'delay' ms
            t = setTimeout(() => {
              t = null;
              fn.apply(lastThis, [...lastArgs, ac.signal]);
            }, delay);
          };
        };

        static timezoned(utcString) {
          const d = new Date(utcString);
          const dd = String(d.getDate()).padStart(2, "0");
          const mm = String(d.getMonth() + 1).padStart(2, "0"); // month is 0-based
          const yyyy = d.getFullYear();
          const hh = String(d.getHours()).padStart(2, "0");
          const min = String(d.getMinutes()).padStart(2, "0");
          return `${dd}.${mm}.${yyyy} ${hh}:${min}`;
        }
      }

      /**
       * UI Class
       * Handles all UI interactions and element references.
       */
      class UI {
        static EVENTS = {
          SLUG_INPUT: Symbol(),
          SAVE: Symbol(),
          PURGE: Symbol(),
          ENTRY_COPY: Symbol(),
          ENTRY_DELETE: Symbol(),
        }

        #el = {
          entryList: '#entryList',
          entryStatus: '#entryStatus',
          saveInput: '#saveInput',
          saveButton: '#saveButton',
          slugInput: '#slugInput',
          purgeButton: '#purgeButton',
          saveStatusLabel: '#saveStatusLabel',
          footnote: '#footnote',
        };

        #selectors = {
          entryItem: '.entry-item',
          entryHeader: '.entry-header',
          entryDeleteButton: 'button.delete',
          entryCopyButton: 'button.copy'
        };

        #eventListeners = [];
        #timeouts = {};

        constructor() {
          // Collect all elements
          Object.keys(this.#el).forEach(key => {
            this.#el[key] = document.querySelector(this.#el[key]);
          });

          /**
           * Event Listeners
           * Bind all event listeners to the UI elements.
           */
          this.#el.purgeButton.addEventListener('click', this.#emitEvent.bind(this, UI.EVENTS.PURGE));
          this.#el.saveButton.addEventListener('click', this.#emitEvent.bind(this, UI.EVENTS.SAVE));

          const slugInputEmit = Utils.debounce(this.#emitEvent.bind(this), 500);
          this.#el.slugInput.addEventListener('input', () => {
            const $input = this.#el.slugInput;
            const start = $input.selectionStart;
            const length = $input.value.length;
            $input.value = Model.getValidSlug($input.value);
            const caretPos = $input.value.length == length ? start : start - 1;
            $input.setSelectionRange(caretPos, caretPos); // keep caret stable
            slugInputEmit(UI.EVENTS.SLUG_INPUT, {slug: $input.value});
          });

          this.#el.saveInput.addEventListener('input', function() {
            this.style.height = 'auto'; // reset so shrink works
            this.style.height = this.scrollHeight + 10 + 'px';  
          });

          this.#el.entryList.addEventListener('click', (event) => {
            const entryItem = event.target.closest(this.#selectors.entryItem);
            if (!entryItem) return; // click wasn't inside an entry item

            const id = +entryItem.dataset.id; // <li data-id="...">

            if (event.target.closest(this.#selectors.entryDeleteButton)) {
              return this.#emitEvent(UI.EVENTS.ENTRY_DELETE, {id});
            }

            if (event.target.closest(this.#selectors.entryCopyButton)) {
              return this.#emitEvent(UI.EVENTS.ENTRY_COPY, {id});
            }

            if (event.target.closest(this.#selectors.entryHeader)) {
              return entryItem.classList.toggle('expanded');
            }
          });
        }

        #emitEvent(name, ...args) {
          this.#eventListeners.forEach(listener => {
            listener(name, ...args);
          });
        }

        addListener(callback) {
          this.#eventListeners.push(callback);
        }

        #scheduleTimeout(key, delay, callback) {
          if (this.#timeouts[key]) {
            clearTimeout(this.#timeouts[key]);
          }
          this.#timeouts[key] = setTimeout(() => {
            callback();
            delete this.#timeouts[key];
          }, delay);
        }

        #setButtonSuccess(selector, text, delay = 2000) {
          const button = document.querySelector(selector);
          
          if (!button) return;
          const originalText = button.textContent;

          button.classList.add('success-button');
          button.textContent = text;

          this.#scheduleTimeout(`buttonSuccessTimeout-${selector}`, delay, () => {
            button.classList.remove('success-button');
            button.textContent = originalText;
          });
        }

        #setButtonInProgress(buttonOrSelector, text) {
          const button = typeof buttonOrSelector === 'string'
            ? document.querySelector(buttonOrSelector)
            : buttonOrSelector;

          if (!button) return;
          const originalText = button.textContent;

          button.disabled = true;
          button.textContent = text;

          return () => {
            button.disabled = false;
            button.textContent = originalText;
          };
        }

        #getAllInputElements() {
          return [
            this.#el.saveInput,
            this.#el.slugInput,
            this.#el.purgeButton,
            this.#el.saveButton,
            ...this.#el.entryList.querySelectorAll(`${this.#selectors.entryDeleteButton}, ${this.#selectors.entryCopyButton}`)
          ];
        }

        setInProgress(inProgress) {
          this.#getAllInputElements().forEach(input => {
            input.disabled = inProgress;
          });  
        }

        getEntryItemSelector(id) {
          return `${this.#selectors.entryItem}[data-id="${id}"]`;
        }

        setCopyButtonSuccess(id) {
          this.#setButtonSuccess(
            `${this.getEntryItemSelector(id)} ${this.#selectors.entryCopyButton}`,
            'Copied!',
            2000
          );
        }

        setDeleteButtonInProgress(id) {
          return this.#setButtonInProgress(
            `${this.getEntryItemSelector(id)} ${this.#selectors.entryDeleteButton}`,
            'Deleting...'
          );
        }

        setSaveButtonInProgress() {
          return this.#setButtonInProgress(
            this.#el.saveButton,
            'Saving...'
          );
        }

        setPurgeButtonInProgress() {
          return this.#setButtonInProgress(
            this.#el.purgeButton,
            'Purging...'
          );
        }

        enablePurgeButton(enable) {
          this.#el.purgeButton.disabled = !enable;
        }

        clearSaveInput() {
          this.#el.saveInput.value = '';
          this.#el.saveInput.style.height = 'auto'; // reset height
        }

        getSaveInputValue() {
          return this.#el.saveInput.value.trim();
        }

        showEl(el) {
          el.classList.remove('hidden');
        }

        hideEl(el) {
          el.classList.add('hidden');
        }

        renderSlug(slug) {
          this.#el.slugInput.value = slug;
        }

        focusSlugInput() {
          this.#el.slugInput.focus();
        }

        showEntryStatus(text, error = false) {
          this.#el.entryStatus.classList[error ? 'add' : 'remove']('error');
          this.#el.entryStatus.textContent = text;
          this.showEl(this.#el.entryStatus);
        }

        hideEntryStatus() {
          this.hideEl(this.#el.entryStatus);
        }

        renderEntryItem(entry) {
          const entryItem = `
            <li class="entry-item" data-id="${entry.id}">
              <div class="entry-header bg-diaglines">
                <div class="entry-summary">
                  <svg class="chev" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                  ${entry.content.substring(0, 100)}
                </div>
                <div class="entry-id">#${entry.id}</div>
              </div>
              <div class="entry-body">
                <div class="entry-content">${entry.content}</div>
                <div class="entry-footer">
                  <button class="delete danger-button">Delete</button>
                  <button class="copy safe-button">Copy</button>
                </div>
              </div>
            </li>`;
          
          this.#el.entryList.insertAdjacentHTML('beforeend', entryItem);
          this.showEl(this.#el.entryList);
          this.hideEntryStatus();
        }

        hideEntries() {
          this.hideEl(this.#el.entryList);
          this.hideEl(this.#el.saveStatusLabel);
          this.hideEl(this.#el.footnote);
          this.showEntryStatus('No entries yet.');
        }

        showEntries(entries) {
          this.#el.entryList.innerHTML = '';

          if (!entries || entries.length === 0) {
            return this.hideEntries();
          }

          entries.forEach(entry => this.renderEntryItem(entry));
        }

        removeEntryItem(id) {
          const entryItem = this.#el.entryList.querySelector(this.getEntryItemSelector(id));
          if (entryItem) entryItem.remove();
        }

        showSaveStatus(error, slug, random) {
          this.#el.saveStatusLabel.classList[error ? 'add' : 'remove']('error');
          this.#el.saveStatusLabel.innerHTML = error ?
            `Failed to save entry. Please try again. (Reason: ${error})` :
            `${random ? `Entry saved to vault with randomly generated slug` : `Entry saved to vault with slug`}
              <strong>${slug}</strong>. Access via 
              <a href="https://clip.rames.dev/${slug}" target="_blank">https://clip.rames.dev/${slug}</a>
              or by typing the slug into the input field at the top.
            `;
          this.#el.saveStatusLabel.classList.remove('hidden');
        }

        hideSaveStatus() {
          this.hideEl(this.#el.saveStatusLabel);
        }

        updatePurgeTime(purgeTime) {
          if (!purgeTime) {
            this.hideEl(this.#el.footnote);
            return;
          }

          this.#el.footnote.querySelector('strong').textContent = Utils.timezoned(purgeTime);
          this.showEl(this.#el.footnote);
        }
      }

      /**
       * StateMachine
       * A simple state machine to manage application states and transitions.
       */
      class StateMachine {
        #handlers = null;
        #current = null;
        #context = null;

        constructor(context, current, handlers) {
          this.#handlers = handlers;
          this.#current = current;
          this.#context = context;

          this.send = this.send.bind(this);
        }

        async init() {
          await this.#enterState(this.#current);
        }

        async #exitState () {
          await this.#handlers[this.#current]?.onExit?.(this.#context);
        }

        async #enterState(nextState) {
          this.#current = nextState;
          this.#context.locals = {}; // Reset local state data
          nextState = await this.#handlers[this.#current]?.onEnter?.(this.#context);
          if (nextState && nextState !== this.#current) {
            await this.#transition(nextState);
          }
        }

        async #transition(nextState) {
          await this.#exitState();
          await this.#enterState(nextState);
        }

        async send(event, args) {
          const handler = this.#handlers[this.#current]?.onEvent?.[event];
          const nextState = await handler?.(this.#context, args);

          if (nextState && nextState !== this.#current) {
            await this.#transition(nextState);
          }
        }
      }

      /**
       * API Class
       * Handles API interactions and requests.
       */
      class API {
        static async fetch(path, method, data) {
          const res = await fetch(`/api${path}`, {
            method,
            headers: {'Content-Type': 'application/json'},
            body: data ? JSON.stringify(data) : undefined
          });

          if (!res.ok) {
            return {error: `API responded with ${res.status}`}
          }

          return res.json(); // always parse JSON
        }

        static async fetchEntries(slug) {
          return API.fetch(`/entries/${slug}`, 'GET');
        }

        static async saveEntry(slug, content) {
          return API.fetch(`/entries/${slug}`, 'POST', {content});
        }

        static async purgeEntries(slug) {
          return API.fetch(`/entries/${slug}`, 'DELETE');
        }

        static async deleteEntry(slug, id) {
          return API.fetch(`/entry/${slug}/${id}`, 'DELETE');
        }
      }

      /**
       * Model Class
       * Represents the data model for the application.
       */
      class Model {
        static getValidSlug(slug) {
          return slug.replace(/[^a-z0-9]/gi, '')
        }

        #slug = null;
        #entries = [];
        #metadata = {
          purgeTime: null,
        };

        setSlug(slug) {
          this.#slug = slug;
        }

        getSlug() {
          return this.#slug;
        }

        getEntryCount() {
          return this.#entries?.length || 0;
        }

        getEntryById(id) {
          return this.#entries.find(entry => entry.id === id);
        }

        getPurgeTime() {
          return this.#metadata.purgeTime;
        }

        async fetchEntries() {
          const res = await API.fetchEntries(this.#slug);
          if (res && !res.error) {
            this.#entries = res.entries || [];
            this.#metadata.purgeTime = res.purgeTime;
          }
          return res;
        }

        async removeEntryById(id) {
          const res = await API.deleteEntry(this.#slug, id);
          if (!res.error) {
            this.#entries = this.#entries.filter(entry => entry.id !== id);
            this.#metadata.purgeTime = res.purgeTime;
          }
          if (this.#entries.length === 0) {
            this.#metadata.purgeTime = null; // Reset purge time if no entries left
          }
          return res;
        }

        async saveEntry(content) {
          const res = await API.saveEntry(this.#slug, content);
          if (!res.error) {
            this.#entries.push({id: res.id, content});
            this.#metadata.purgeTime = res.purgeTime;
          }
          return res;
        }

        async purgeEntries() {
          const res = await API.purgeEntries(this.#slug);
          if (!res.error) {
            this.#entries = [];
            this.#metadata.purgeTime = null;
          }
          return res;
        }
      }
      
      /**
       * App Class
       * Main application logic and state management.
       */
      const STATES = {
        INIT: Symbol(),
        IDLE: Symbol(),
        SAVING: Symbol(),
        PURGING: Symbol(),
      };
      
      class App {
        #ui = null;
        #sm = null;
        #ctx = null;
        #model = null;

        constructor() {
          this.#ui = new UI();
          
          this.#ctx = {
            ui: this.#ui,
          };

          this.resetModel();
          
          this.#sm = new StateMachine(this.#ctx, STATES.INIT, this);
          this.#ui.addListener(this.#sm.send);
          this.#sm.init();
        }

        resetModel() {
          this.#model = new Model();
          this.#ctx.model = this.#model;
          this.updatePurgeTime();
        }

        updatePurgeTime() {
          this.#ui.updatePurgeTime(this.#model.getPurgeTime());
        }

        togglePurgeButton() {
          this.#ui.enablePurgeButton(this.#model.getSlug() && this.#model.getEntryCount())
        }

        generateRandomSlug(len = 4) {
          const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          const array = new Uint8Array(len);
          crypto.getRandomValues(array);
          return Array.from(array, x => chars[x % chars.length]).join('');
        }

        /**
         * State: INIT
         * Initializes the application and transitions to IDLE state.
         */
        [STATES.INIT] = {
          onEnter: async ctx => {
            console.log('INIT:OnEnter');

            this.resetModel();

            ctx.ui.hideSaveStatus();
            ctx.ui.setInProgress(true);

            const urlSlug = window.location.pathname.substring(1);
            const slug = Model.getValidSlug(urlSlug);

            // If provided slug is invalid, redirect to root.
            if (urlSlug !== slug) {
              window.location.href = '/';
              return;
            }

            // If no slug, transition to IDLE state.
            if (!slug) {
              ctx.ui.showEntries(null);
              return STATES.IDLE;
            }

            // Otherwise, update the slug and fetch entries.
            ctx.ui.renderSlug(slug);
            ctx.model.setSlug(slug);

            const {entries, error} = await ctx.model.fetchEntries();

            if (error) {
              ctx.ui.showEntryStatus(`Failed to load entries. Try again. (Reason: ${error})`, true);
            } else {
              ctx.ui.showEntries(entries);
            }

            return STATES.IDLE;
          },

          onExit: ctx => {
            console.log('INIT:OnExit');

            ctx.ui.setInProgress(false);
            ctx.ui.focusSlugInput();
          },
        };
        
        /**
         * State: IDLE
         * Handles user interactions and manages the idle state.
         */
        [STATES.IDLE] = {
          onEnter: ctx => {
            console.log('IDLE:OnEnter');
            this.updatePurgeTime();
            this.togglePurgeButton();
          },
          onEvent: {
            [UI.EVENTS.SLUG_INPUT]: (ctx, {slug}) => {
              console.log('IDLE:OnEvent:SLUG_INPUT', slug);
              
              window.history.replaceState({}, '', `/${slug}`);
              return STATES.INIT; // Reinitialize with new slug
            },
            [UI.EVENTS.ENTRY_COPY]: async (ctx, {id}) => {
              console.log('IDLE:OnEvent:ENTRY_COPY', id);

              const entry = ctx.model.getEntryById(id);
              await navigator.clipboard.writeText(entry.content);
              ctx.ui.setCopyButtonSuccess(id);
            },
            [UI.EVENTS.ENTRY_DELETE]: async (ctx, {id}) => {
              console.log('IDLE:OnEvent:ENTRY_DELETE', id);

              if (confirm(`This action will permanently delete entry #${id}. Continue?`)) {
                const unsetDeleteButtonInProgress = ctx.ui.setDeleteButtonInProgress(id);
                const {error} = await ctx.model.removeEntryById(id);
                
                if (error) {
                  unsetDeleteButtonInProgress();
                  alert(`Failed to delete entry #${id}. (Reason: ${error})`);
                } else {
                  ctx.ui.removeEntryItem(id);
                }

                if (ctx.model.getEntryCount() === 0) {
                  ctx.ui.hideEntries();
                }

                this.updatePurgeTime();
                this.togglePurgeButton();
              }
            },
            [UI.EVENTS.SAVE]: ctx => {
              console.log('IDLE:OnEvent:SAVE');

              const content = ctx.ui.getSaveInputValue();
              if (!content) return;

              return STATES.SAVING;
            },
            [UI.EVENTS.PURGE]: ctx => {
              console.log('IDLE:OnEvent:PURGE');
              if (confirm('This action will permanently delete all entries in this vault. Continue?')) {
                return STATES.PURGING;
              }
            },
          }
        };

        /**
         * State: SAVING
         * Handles the saving logic and transitions back to IDLE state.
         */
        [STATES.SAVING] = {
          onEnter: async (ctx) => {
            console.log('SAVING:OnEnter');

            const unsetSaveButtonInProgress = ctx.ui.setSaveButtonInProgress();
            ctx.ui.setInProgress(true);

            let slug = ctx.model.getSlug();
            let random = !slug; // If slug is empty, we will generate a random one

            if (random) {
              slug = this.generateRandomSlug();
              ctx.model.setSlug(slug);
            }

            const content = ctx.ui.getSaveInputValue();
            const {id, error} = await ctx.model.saveEntry(content);

            if (error) {
              this.resetModel();
            } else {
              ctx.ui.renderEntryItem({id, content});
              ctx.ui.clearSaveInput();

              if (random) {
                ctx.ui.renderSlug(slug);
                window.history.replaceState({}, '', `/${slug}`); // Update URL with new slug
              }
            } 
            
            ctx.ui.showSaveStatus(error, slug, random);
            unsetSaveButtonInProgress();
            ctx.ui.setInProgress(false); 

            return STATES.IDLE;
          }
        };

        /**
         * State: PURGING
         * Handles the purging logic and transitions back to IDLE state.
         */
        [STATES.PURGING] = {
          onEnter: async (ctx) => {
            console.log('PURGING:OnEnter');

            const unsetPurgeButtonInProgress = ctx.ui.setPurgeButtonInProgress();
            ctx.ui.setInProgress(true);

            const {error} = await ctx.model.purgeEntries();

            if (error) {
              alert(`Failed to purge entries. (Reason: ${error})`);
            } else {
              ctx.ui.showEntries(null);
            }

            unsetPurgeButtonInProgress();
            ctx.ui.setInProgress(false);

            return STATES.IDLE;
          },
        };
      }

      // Initialize the application
      globalThis.app = new App();
    </script>
</body>
</html>
